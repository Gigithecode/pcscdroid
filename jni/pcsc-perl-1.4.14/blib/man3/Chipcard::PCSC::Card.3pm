.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Card 3pm"
.TH Card 3pm "2010-10-27" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Chipcard::PCSC::Card \- Smart card communication library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& $hCard = new Chipcard::PCSC::Card ($hContext, "GemPC430 0 0",
\&        $Chipcard::PCSC::SCARD_SHARE_EXCLUSIVE);
\&
\& $RecvData = $hCard\->Transmit([0xBC,0xB0,0x09,0xC8, 2]);
\&
\& $hCard\->Disconnect($Chipcard::PCSC::SCARD_LEAVE_CARD);
\&
\& $hCard\->Status();
\&
\& $hCard\->BeginTransaction();
\&
\& $hCard\->EndTransaction();
\&
\& $hCard\->TransmitWithCheck($apdu, $sw_expected [, $debug]);
\&
\& $hCard\->Control($control_code, \e@data);
\&
\& ISO7816Error($sw);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Chipcard::PCSC::Card\*(C'\fR module implements the
\&\f(CW\*(C`Chipcard::PCSC::Card\*(C'\fR class. Objects from this class are used to
communicate with a given reader. They are constructed out of a reference
to a \s-1PCSC\s0 object that drives the reader.
.PP
For more information about \s-1PC/SC\s0 please read the \fI\fIpcscd\fI\|(1)\fR man page.
.PP
A \f(CW\*(C`Chipcard::PCSC::Card\*(C'\fR object uses the following property:
.IP "\(bu" 4
\&\fB\f(CB$pcsccard_object\fB\->{hContext}\fR
.Sp
the reference to the underlying \s-1PCSC\s0 object
.IP "\(bu" 4
\&\fB\f(CB$pcsccard_object\fB\->{hCard}\fR
.Sp
the current \s-1PCSC\s0 connection handle
.IP "\(bu" 4
\&\fB\f(CB$pcsccard_object\fB\->{dwProtocol}\fR
.Sp
the protocol being used
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
The following methods construct a \f(CW\*(C`Chipcard::PCSC::Card\*(C'\fR object:
.IP "\(bu" 4
\&\fB\f(CB$hCard\fB = new Chipcard::PCSC::Card ($hContext);\fR
.Sp
Constructs a new \f(CW\*(C`Chipcard::PCSC::Card\*(C'\fR object without connecting to
any reader.
.Sp
\&\f(CW$hContext\fR is mandatory and contains the reference to a valid \s-1PCSC\s0
object.
.IP "\(bu" 4
\&\fB\f(CB$hCard\fB = new Chipcard::PCSC::Card ($hContext, \f(CB$reader_name\fB, \f(CB$share_mode\fB, \f(CB$preferred_protocol\fB);\fR
.Sp
Constructs a new Chipcard::PCSC::Card object and connect to the
specified reader.
.RS 4
.IP "\(bu" 4
\&\f(CW$hContext\fR
.Sp
is mandatory and contains the reference to a valid \s-1PCSC\s0 object.
.IP "\(bu" 4
\&\f(CW$reader_name\fR
.Sp
is the name of the reader you want to connect to. It is of the form
\&\*(L"GemPC410 0 0\*(R".
.Sp
Please note that the list of available readers can be obtained with a
call to \f(CW\*(C`$hContext\->ListReaders()\*(C'\fR. (See the section named \fI\s-1PCSC
METHODS\s0\fR in the \fIChipcard::PCSC\fR man page for more information on
\&\f(CW\*(C`ListReaders\*(C'\fR).
.IP "\(bu" 4
\&\f(CW$share_mode\fR
.Sp
is the desired mode of connection to the reader. It can be
any of the following:
.RS 4
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_SHARE_EXCLUSIVE\fR
.Sp
the application do not share the reader
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_SHARE_SHARED\fR
.Sp
the application will allow others to share the reader.
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_SHARE_DIRECT\fR
.Sp
(not used by PC/SC\-lite)
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\f(CW$preferred_protocol\fR
.Sp
is the protocol which should be used if possible.  If the protocol is
not available, another protocol will be used and
\&\f(CW\*(C`$hCard\->{dwProtocol}\*(C'\fR will be set accordingly. Both
\&\f(CW\*(C`$hCard\->{dwProtocol}\*(C'\fR and \f(CW$preferred_protocol\fR accept the
following values:
.RS 4
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_T0\fR
.Sp
the T=0 protocol
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_T1\fR
.Sp
the T=1 protocol
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_RAW\fR
.Sp
raw protocol
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\fB\f(CB$hCard\fB = new Chipcard::PCSC::Card ($hContext, \f(CB$reader_name\fB, \f(CB$share_mode\fB);\fR
.Sp
This method is equivalent to:
.Sp
.Vb 4
\& $hCard = new Chipcard::PCSC::Card ($hContext, $reader_name,
\&    $share_mode,
\&    $Chipcard::PCSC::SCARD_PROTOCOL_T0 |
\&    $Chipcard::PCSC::SCARD_PROTOCOL_T1);
.Ve
.IP "\(bu" 4
\&\fB\f(CB$hCard\fB = new Chipcard::PCSC::Card ($hContext, \f(CB$reader_name\fB);\fR
.Sp
This method is equivalent to:
.Sp
.Vb 4
\& $hCard = new Chipcard::PCSC::Card ($hContext, $reader_name,
\&    $Chipcard::PCSC::SCARD_SHARE_EXCLUSIVE,
\&    $Chipcard::PCSC::SCARD_PROTOCOL_T0 |
\&    $Chipcard::PCSC::SCARD_PROTOCOL_T1);
.Ve
.SH "CONSTRUCTION FAILURE"
.IX Header "CONSTRUCTION FAILURE"
\&\f(CW\*(C`Chipcard::PCSC::Card\*(C'\fR constructors return an \f(CW\*(C`undef\*(C'\fR value when the
object can not be created. \f(CW$Chipcard::PCSC::errno\fR can be used to get
more information about the error. See section \fI\s-1ERROR HANDLING\s0\fR in
\&\fIChipcard::PCSC\fR man page for more information.
.SH "Chipcard::PCSC::Card METHODS"
.IX Header "Chipcard::PCSC::Card METHODS"
Here is a list of all the methods that can be used with a \f(CW\*(C`Chipcard::PCSC::Card\*(C'\fR
object.
.ie n .SS " $hCard\->Connect($reader_name, $share_mode, $preferred_protocol);"
.el .SS " \f(CW$hCard\fP\->Connect($reader_name, \f(CW$share_mode\fP, \f(CW$preferred_protocol\fP);"
.IX Subsection " $hCard->Connect($reader_name, $share_mode, $preferred_protocol);"
\&\f(CW\*(C`Connect()\*(C'\fR can be used to connect to the reader and its smart card if
the connection has not been established yet. The default constructor can
establish the connection if given enough parameters.
.PP
The return value upon successful completion is the protocol used to
communicate with the smart card. It can be any of the following:
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_T0\fR
.Sp
the T=0 protocol
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_T1\fR
.Sp
the T=1 protocol
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_RAW\fR
.Sp
raw protocol
.IP "\(bu" 4
\&\f(CW$reader_name\fR
.Sp
is mandatory. It contains the name of the reader you want to connect to.
It is of the form \*(L"GemPC410 0 0\*(R".
.Sp
Please note that the list of available readers can be obtained with a
call to \f(CW\*(C`$hContext\->ListReaders()\*(C'\fR. (See the section named \fI\s-1PCSC
METHODS\s0\fR in the \fIChipcard::PCSC\fR man page for more information on
\&\f(CW\*(C`ListReaders\*(C'\fR).
.IP "\(bu" 4
\&\f(CW$share_mode\fR
.Sp
is the desired mode of connection to the reader. It can be any of the
following:
.RS 4
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_SHARE_EXCLUSIVE\fR
.Sp
the application do not share the reader
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_SHARE_SHARED\fR
.Sp
the application will allow others to share the reader.
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_SHARE_DIRECT\fR
.Sp
(not used by PCSClite)
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\f(CW$preferred_protocol\fR
.Sp
is the protocol which should be used if possible. If the protocol is not
available, another protocol will be used and
\&\f(CW\*(C`$hCard\->{dwProtocol}\*(C'\fR will be set accordingly.
\&\f(CW$preferred_protocol\fR accept the following values:
.RS 4
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_T0\fR
.Sp
the T=0 protocol
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_T1\fR
.Sp
the T=1 protocol
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_RAW\fR
.Sp
raw protocol
.RE
.RS 4
.RE
.ie n .SS " $hCard\->Connect($reader_name, $share_mode);"
.el .SS " \f(CW$hCard\fP\->Connect($reader_name, \f(CW$share_mode\fP);"
.IX Subsection " $hCard->Connect($reader_name, $share_mode);"
This method is equivalent to:
.PP
.Vb 3
\& $hCard\->Connect($reader_name, $share_mode,
\&    $Chipcard::PCSC::SCARD_PROTOCOL_T0 |
\&    $Chipcard::PCSC::SCARD_PROTOCOL_T1);
.Ve
.ie n .SS " $hCard\->Connect($reader_name);"
.el .SS " \f(CW$hCard\fP\->Connect($reader_name);"
.IX Subsection " $hCard->Connect($reader_name);"
This method is equivalent to:
.PP
.Vb 3
\& $hCard\->Connect($reader_name, $Chipcard::PCSC::SCARD_SHARE_EXCLUSIVE,
\&    $Chipcard::PCSC::SCARD_PROTOCOL_T0 |
\&    $Chipcard::PCSC::SCARD_PROTOCOL_T1);
.Ve
.ie n .SS " $hCard\->Reconnect($share_mode, $preferred_protocol, $initialization);"
.el .SS " \f(CW$hCard\fP\->Reconnect($share_mode, \f(CW$preferred_protocol\fP, \f(CW$initialization\fP);"
.IX Subsection " $hCard->Reconnect($share_mode, $preferred_protocol, $initialization);"
\&\f(CW\*(C`Reconnect()\*(C'\fR can be used to re-negotiate an already opened connection.
This implies that the \f(CW\*(C`Chipcard::PCSC::Card\*(C'\fR object is connected and
has \f(CW\*(C`$hCard\->{hCard}\*(C'\fR set accordingly.
.PP
Reconnecting to a smart card is used to change the share mode and the
current protocol.
.PP
The return value upon successful completion is the protocol choose to
communicate with the smart card. It can be any of the following:
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_T0\fR
.Sp
the T=0 protocol
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_T1\fR
.Sp
the T=1 protocol
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_RAW\fR
.Sp
raw protocol
.IP "\(bu" 4
\&\f(CW$share_mode\fR
.Sp
is the desired mode of connection to the reader. It can be any of the
following:
.RS 4
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_SHARE_EXCLUSIVE\fR
.Sp
the application do not share the reader
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_SHARE_SHARED\fR
.Sp
the application will allow others to share the reader.
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_SHARE_DIRECT\fR
.Sp
(not used by PCSClite)
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\f(CW$preferred_protocol\fR
.Sp
is the protocol which should be used if possible. If the protocol is not
available, another protocol will be used and
\&\f(CW\*(C`$hCard\->{dwProtocol}\*(C'\fR will be set accordingly.
\&\f(CW$preferred_protocol\fR accept the following values:
.RS 4
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_T0\fR
.Sp
the T=0 protocol
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_T1\fR
.Sp
the T=1 protocol
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_RAW\fR
.Sp
raw protocol
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\f(CW$initialization\fR
.Sp
is the action to take when reconnecting to the smart card. It can be any
of the following values:
.RS 4
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_LEAVE_CARD\fR
.Sp
do nothing on close
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_RESET_CARD\fR
.Sp
reset on close
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_UNPOWER_CARD\fR
.Sp
power down on close
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_EJECT_CARD\fR
.Sp
eject on close
.RE
.RS 4
.RE
.ie n .SS " $hCard\->Reconnect($share_mode, $preferred_protocol);"
.el .SS " \f(CW$hCard\fP\->Reconnect($share_mode, \f(CW$preferred_protocol\fP);"
.IX Subsection " $hCard->Reconnect($share_mode, $preferred_protocol);"
This method is equivalent to:
.PP
.Vb 2
\& $hCard\->Reconnect($share_mode, $preferred_protocol,
\&    $Chipcard::PCSC::SCARD_LEAVE_CARD);
.Ve
.ie n .SS " $hCard\->Reconnect($share_mode);"
.el .SS " \f(CW$hCard\fP\->Reconnect($share_mode);"
.IX Subsection " $hCard->Reconnect($share_mode);"
This method is equivalent to:
.PP
.Vb 4
\& $hCard\->Reconnect($share_mode,
\&    $Chipcard::PCSC::SCARD_PROTOCOL_T0 |
\&    $Chipcard::PCSC::SCARD_PROTOCOL_T1,
\&    $Chipcard::PCSC::SCARD_LEAVE_CARD);
.Ve
.ie n .SS " $hCard\->\fIReconnect()\fP;"
.el .SS " \f(CW$hCard\fP\->\fIReconnect()\fP;"
.IX Subsection " $hCard->Reconnect();"
This method is equivalent to:
.PP
.Vb 4
\& $hCard\->Reconnect($Chipcard::PCSC::SCARD_SHARE_EXCLUSIVE,
\&    $Chipcard::PCSC::SCARD_PROTOCOL_T0 |
\&    $Chipcard::PCSC::SCARD_PROTOCOL_T1,
\&    $Chipcard::PCSC::SCARD_LEAVE_CARD);
.Ve
.ie n .SS " $hCard\->Disconnect($initialization);"
.el .SS " \f(CW$hCard\fP\->Disconnect($initialization);"
.IX Subsection " $hCard->Disconnect($initialization);"
\&\f(CW\*(C`Disconnect()\*(C'\fR closes the connection to the smart card reader. It
returns true upon successful completion or undef otherwise.
\&\f(CW\*(C`$hCard\->{hContext}\*(C'\fR will be set to undef if the connection is
successfully closed.
.IP "\(bu" 4
\&\f(CW$initialization\fR
.Sp
is the action to take when reconnecting to the smart card. It can be any
of the following values:
.RS 4
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_LEAVE_CARD\fR
.Sp
do nothing on close
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_RESET_CARD\fR
.Sp
reset on close
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_UNPOWER_CARD\fR
.Sp
power down on close
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_EJECT_CARD\fR
.Sp
eject on close
.RE
.RS 4
.RE
.ie n .SS " $hCard\->\fIDisconnect()\fP;"
.el .SS " \f(CW$hCard\fP\->\fIDisconnect()\fP;"
.IX Subsection " $hCard->Disconnect();"
This method is equivalent to:
.PP
.Vb 1
\& $hCard\->Disconnect($Chipcard::PCSC::SCARD_EJECT_CARD);
.Ve
.ie n .SS " $hCard\->\fIStatus()\fP;"
.el .SS " \f(CW$hCard\fP\->\fIStatus()\fP;"
.IX Subsection " $hCard->Status();"
\&\f(CW\*(C`Status()\*(C'\fR returns the current status of the connection to a smart card.
It is used to retrieve the \s-1ATR \s0(Answer To Reset) value as well as the
protocol being used to communicate.
.PP
The return value is the \f(CW\*(C`undef\*(C'\fR value if an error occurs. In such a
case, \f(CW$!\fR should be set with a string describing the error. Upon
successful completion \f(CW\*(C`Status\*(C'\fR returns an array as follows:
(\f(CW$reader_name\fR, \f(CW$reader_state\fR, \f(CW$protocol\fR, \f(CW\*(C`\e@atr\*(C'\fR)
.IP "\(bu" 4
\&\f(CW$reader_name\fR
.Sp
is a string containing the name of the reader
.IP "\(bu" 4
\&\f(CW$reader_state\fR
.Sp
is a scalar containing the current state of the reader.
.Sp
It can be any combination of the following values:
.RS 4
.IP "\(bu" 5
\&\f(CW$Chipcard::PCSC::SCARD_UNKNOWN\fR
.Sp
unknown state
.IP "\(bu" 5
\&\f(CW$Chipcard::PCSC::SCARD_ABSENT\fR
.Sp
card is absent
.IP "\(bu" 5
\&\f(CW$Chipcard::PCSC::SCARD_PRESENT\fR
.Sp
card is present
.IP "\(bu" 5
\&\f(CW$Chipcard::PCSC::SCARD_SWALLOWED\fR
.Sp
card not powered
.IP "\(bu" 5
\&\f(CW$Chipcard::PCSC::SCARD_POWERED\fR
.Sp
card is powered
.IP "\(bu" 5
\&\f(CW$Chipcard::PCSC::SCARD_NEGOTIABLE\fR
.Sp
ready for \s-1PTS\s0
.IP "\(bu" 5
\&\f(CW$Chipcard::PCSC::SCARD_SPECIFIC\fR
.Sp
\&\s-1PTS\s0 has been set
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\f(CW$protocol\fR
.Sp
is the protocol being used. It can be any of the following values:
.RS 4
.IP "\(bu" 5
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_T0\fR,
.IP "\(bu" 5
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_T1\fR,
.IP "\(bu" 5
\&\f(CW$Chipcard::PCSC::SCARD_PROTOCOL_RAW\fR
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\e@atr
.Sp
is a reference to an array containing the \s-1ATR.\s0 Each cell of the array
contains one byte of the \s-1ATR.\s0 This parameter is however optional as the
\&\s-1ATR\s0 may not be available under some circumstances. For instance when the
card is not inserted, no \s-1ATR\s0 can be returned and this parameter will be
\&\f(CW\*(C`undef\*(C'\fR.
.ie n .SS " $hCard\->Transmit(\e@data);"
.el .SS " \f(CW$hCard\fP\->Transmit(\e@data);"
.IX Subsection " $hCard->Transmit(@data);"
\&\f(CW\*(C`Transmit()\*(C'\fR is used to exchange data with the card.
.PP
It returns a reference to an anonymous array holding the answer to the
emitted data. In case of an error, the reference is the \f(CW\*(C`undef\*(C'\fR value.
.IP "\(bu" 4
\&\e@data
.Sp
is a reference to the data to be sent to the card.
.PP
Here is a small sample of how to use \f(CW\*(C`transmit\*(C'\fR:
.PP
.Vb 2
\& $SendData = [0x00, 0xA4, 0x01, 0x00, 0x02, 0x01, 0x00];
\& $RecvData = $hCard\->Transmit($SendData);
\&
\& print "  Recv = ";
\& foreach $tmpVal (@{$RecvData}) {
\&     printf ("%02X ", $tmpVal);
\& } print "\en";
.Ve
.ie n .SS " $hCard\->\fIBeginTransaction()\fP;"
.el .SS " \f(CW$hCard\fP\->\fIBeginTransaction()\fP;"
.IX Subsection " $hCard->BeginTransaction();"
\&\f(CW\*(C`BeginTransaction()\*(C'\fR is used to temporarily get exclusive control over
the smart card.
.PP
It returns \s-1TRUE\s0 upon successful completion and \s-1FALSE\s0 otherwise.
\&\f(CW$Chipcard::PCSC::errno\fR should be set accordingly in case of an error.
See section \fI\s-1ERROR HANDLING\s0\fR in \fIChipcard::PCSC\fR man page for more
information.
.ie n .SS " $hCard\->EndTransaction($disposition);"
.el .SS " \f(CW$hCard\fP\->EndTransaction($disposition);"
.IX Subsection " $hCard->EndTransaction($disposition);"
\&\f(CW\*(C`EndTransaction()\*(C'\fR is used to end a transaction initiated with
\&\f(CW\*(C`BeginTransaction()\*(C'\fR.
.PP
It returns \f(CW\*(C`TRUE\*(C'\fR upon successful completion and \s-1FALSE\s0 otherwise.
\&\f(CW$Chipcard::PCSC::errno\fR should be set accordingly in case of an error.
See section \fI\s-1ERROR HANDLING\s0\fR in \fIChipcard::PCSC\fR man page for more
information.
.IP "\(bu" 4
\&\f(CW$disposition\fR
.Sp
is the action to take when ending the transaction. It can be any of the
following values:
.RS 4
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_LEAVE_CARD\fR
.Sp
do nothing on close
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_RESET_CARD\fR
.Sp
reset on close
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_UNPOWER_CARD\fR
.Sp
power down on close
.IP "\(bu" 4
\&\f(CW$Chipcard::PCSC::SCARD_EJECT_CARD\fR
.Sp
eject on close
.RE
.RS 4
.RE
.ie n .SS " $hCard\->\fIEndTransaction()\fP;"
.el .SS " \f(CW$hCard\fP\->\fIEndTransaction()\fP;"
.IX Subsection " $hCard->EndTransaction();"
This method is equivalent to:
.PP
.Vb 1
\& $hCard\->EndTransaction($Chipcard::PCSC::SCARD_LEAVE_CARD);
.Ve
.ie n .SS " $hCard\->TransmitWithCheck($apdu, $sw_expected [, $debug]);"
.el .SS " \f(CW$hCard\fP\->TransmitWithCheck($apdu, \f(CW$sw_expected\fP [, \f(CW$debug\fP]);"
.IX Subsection " $hCard->TransmitWithCheck($apdu, $sw_expected [, $debug]);"
This method is a wrapper around \f(CW$hCard\fR\->\fITransmit()\fR. The
\&\f(CW$apdu\fR parameter is an \s-1ASCII\s0 text like \*(L"00 A4 01 00 02 01 00\*(R",
\&\f(CW$sw_expected\fR is a Perl regular expression like \*(L"90 [01]0\*(R".
.PP
If the status word returned matches the expression \f(CW$sw_expected\fR the
method returns a list ($sw, \f(CW$recv\fR). \f(CW$sw\fR is the status word (like \*(L"90
00\*(R") of the command, \f(CW$recv\fR is the result of the command.
.PP
If the status word do not match the expression \f(CW$sw_expected\fR the method
returns undef and the variable \f(CW$Chipcard::PCSC::Card::Error\fR is set.
.PP
The \f(CW$debug\fR argument is optional. If present the method will print on
stdout the command sent and the response from the card.
.PP
Example:
.PP
.Vb 2
\& ($sw, $RecvData) = $hCard\->TransmitWithCheck($SendData, "6E 00", 1);
\& warn "TransmitWithCheck: $Chipcard::PCSC::Card::Error" unless defined $sw;
.Ve
.ie n .SS " $hCard\->Control($control_code, \e@data);"
.el .SS " \f(CW$hCard\fP\->Control($control_code, \e@data);"
.IX Subsection " $hCard->Control($control_code, @data);"
This method uses \s-1PC/SC\s0 \fISCardControl()\fR to send data specific to the
reader driver. See your driver documentation to know what data to use.
.PP
Example:
.PP
.Vb 3
\& $data = Chipcard::PCSC::ascii_to_array ("01 23 45");
\& $RecvData = $hCard\->Control(0x42000001, $SendData);
\& die ("Can\*(Aqt Control data: $Chipcard::PCSC::errno") unless (defined ($RecvData));
.Ve
.SS " ISO7816Error($sw);"
.IX Subsection " ISO7816Error($sw);"
This method returns the \s-1ASCII\s0 text corresponding to the status word \f(CW$sw\fR
according to \s-1ISO 7816\-4\s0 specifications.
.PP
Example:
.PP
.Vb 2
\& $sw = "90 00";
\& print "$sw: " . &Chipcard::PCSC::Card::ISO7816Error($sw) . "\en";
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIpcscd\fR man page has useful information about PC/SC\-lite.
\&\fIChipcard::PCSC\fR man page holds all the necessary information to create
the \s-1PCSC\s0 object which will be the basis of \f(CW\*(C`Chipcard::PCSC::Card\*(C'\fR.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
(C) Lionel \s-1VICTOR, 2001, GNU GPL\s0
.PP
(C) Ludovic \s-1ROUSSEAU, 2003\-2008, GNU GPL\s0
.SH "AUTHORS / ACKNOWLEDGEMENT"
.IX Header "AUTHORS / ACKNOWLEDGEMENT"
.Vb 2
\& Lionel VICTOR <lionel.victor@unforgettable.com>
\&               <lionel.victor@free.fr>
\&
\& Ludovic ROUSSEAU <ludovic.rousseau@free.fr>
.Ve
